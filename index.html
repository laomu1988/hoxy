<!doctype html>
<html>
<head>
<title>Documentation - Hoxy</title>
<meta charset="utf8">
<link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,700italic,700,300" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css">
<link href="./page-resources/styles.css" rel="stylesheet" type="text/css">
<link href="./page-resources/prism.css" rel="stylesheet" type="text/css">
<script src="./page-resources/jquery.js"></script>
<script src="./page-resources/de-indent.js"></script>
<script src="./page-resources/prism.js"></script>
</head>
<body>
<div id="outer">
<div id="inner">

<div id="target">

<h1 id="introduction" data-tldr="Documentation and examples.">Hoxy&#x4ECB;&#x7ECD;<a href="#introduction" class="permalink" title="permalink"></a></h1>

<p>
  Hoxy&#x662F;&#x4E00;&#x4E2A;&#x7528;Node&#x7F16;&#x5199;&#x7684;&#x5B8C;&#x5168;&#x514D;&#x8D39;&#x3001;&#x5F00;&#x6E90;&#x7684;Http&#x4EE3;&#x7406;&#x8F6F;&#x4EF6;&#xFF0C;&#x7C7B;&#x4F3C;Charles&#x548C;Fiddler&#x3002;
  &#x5B83;&#x6709;&#x5982;&#x4E0B;&#x7279;&#x70B9;&#xFF1A;
</p>

<ul>
  <li>&#x4E2D;&#x65AD;&#x8BF7;&#x6C42;&#x6216;&#x8005;&#x54CD;&#x5E94;.</li>
  <li>&#x89C2;&#x5BDF;&#x548C;&#x6539;&#x53D8;&#x8BF7;&#x6C42;&#x6216;&#x54CD;&#x5E94;&#x7684;&#x5404;&#x4E2A;&#x90E8;&#x5206;</li>
  <li>&#x6A21;&#x62DF;&#x7F51;&#x7EDC;&#x7684;&#x7F13;&#x6162;&#x548C;&#x5EF6;&#x8FDF;</li>
  <li>&#x652F;&#x6301;&#x76F4;&#x63A5;&#x6216;&#x8005;&#x53CD;&#x5411;&#x4EE3;&#x7406;</li>
  <li>&#x53EF;&#x4EE5;&#x7528;&#x672C;&#x5730;&#x6587;&#x4EF6;&#x4EE3;&#x66FF;&#x8FDC;&#x7A0B;&#x8BF7;&#x6C42;</li>
  <li>&#x8BF7;&#x6C42;&#x6216;&#x8005;&#x54CD;&#x5E94;&#x4E3B;&#x4F53;&#x7C7B;&#x578B;: JSON, string, jQuery, buffer, etc.</li>
  <li>&#x652F;&#x6301;HTTP&#x548C;HTTPS.</li>
</ul>

<p>
  Here are a few ideas for things you could do.
</p>

<p>
  Here are a few ideas for things you could do.
  &#x4E0B;&#x9762;&#x662F;&#x4E00;&#x4E9B;&#x60F3;&#x6CD5;&#x4F60;&#x53EF;&#x80FD;&#x7528;&#x5230;
</p>

<ul>
  <li>Replace your Facebook frineds with pictures of unicorns.</li>
  <li>Add bizarre HTTP request headers to confuse server admins.</li>
  <li>Remove ads from web pages for personal browsing.</li>
  <li>Fuzz test your site&apos;s load sequence by adding random amounts of latency.</li>
  <li>Test changes in production, without pushing to production.</li>
</ul>

<ul>
  <li>&#x628A;&#x4F60;&#x670B;&#x53CB;&#x5708;&#x7684;&#x56FE;&#x7247;&#x66FF;&#x6362;&#x6210;&#x72EC;&#x89D2;&#x517D;.</li>
  <li>&#x6DFB;&#x52A0;&#x4E00;&#x4E9B;headers&#x6807;&#x5FD7;&#x8FF7;&#x60D1;&#x670D;&#x52A1;&#x5668;</li>
  <li>&#x4ECE;&#x6D4F;&#x89C8;&#x5668;&#x4E2D;&#x5220;&#x9664;&#x5E7F;&#x544A;.</li>
  <li>&#x901A;&#x8FC7;&#x6DFB;&#x52A0;&#x4E00;&#x4E9B;&#x968F;&#x673A;&#x91CF;&#x6D4B;&#x8BD5;&#x7F51;&#x7AD9;&#x7684;&#x52A0;&#x8F7D;&#x987A;&#x4FBF;</li>
  <li>&#x5728;&#x63A8;&#x9001;&#x5230;&#x6B63;&#x5F0F;&#x73AF;&#x5883;&#x4E4B;&#x524D;&#x6D4B;&#x8BD5;&#x4EA7;&#x54C1;&#x7684;&#x53D8;&#x5316;</li>
</ul>
<p>
  These docs are for Hoxy 3.x.
  See the <a href="#examples">incantations</a> section for code samples.
</p>
<p>
  &#x4E0B;&#x9762;&#x662F;Hoxy 3.x&#x7684;&#x6587;&#x6863;&#x3002;
  &#x67E5;&#x770B;&#x793A;&#x4F8B;&#x8BF7;&#x70B9;&#x51FB;&#xFF1A; <a href="#examples">&#x5492;&#x8BED;</a> &#x3002;
</p>

<h2 id="how-it-works">&#x5DE5;&#x4F5C;&#x539F;&#x7406;<a href="#how-it-works" class="permalink" title="permalink"></a></h2>

<p>
  Hoxy functions as a normal proxy standing between the client and server.
  You intercept traffic during either the request or response phase, or both.
  The <a href="#phase-lifecycle">phase lifecycle section</a> contains a more complete description, but here&apos;s a simplified illustration.
</p>
<p>
  Hoxy&#x662F;&#x4E00;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x5668;&#x4E4B;&#x95F4;&#x7684;&#x4EE3;&#x7406;&#x5DE5;&#x5177;&#x3002;
  &#x4F60;&#x53EF;&#x4EE5;&#x62E6;&#x622A;&#x8BF7;&#x6C42;&#x6216;&#x8005;&#x54CD;&#x5E94;&#xFF0C;
  &#x4E0B;&#x9762;&#x662F;&#x4E00;&#x5F20;&#x7B80;&#x56FE;&#xFF0C;&#x8BE6;&#x7EC6;&#x60C5;&#x51B5;<a href="#phase-lifecycle">&#x70B9;&#x51FB;&#x67E5;&#x770B;</a>
</p>

<pre class="code">
  time ==&gt;
  -----------------------
  server:       3
  -------------/-\-------
  hoxy:       2   4
  -----------/-----\-----
  client:   1       5
</pre>

<ol>
  <li>&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x9001;&#x8BF7;&#x6C42;.</li>
  <li>Hoxy&#x62E6;&#x622A;&#x5E76;&#x5904;&#x7406;&#x8BF7;&#x6C42;.</li>
  <li>&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x6536;&#x5230;&#x8BF7;&#x6C42;&#x5E76;&#x53D1;&#x9001;&#x54CD;&#x5E94;&#x6570;&#x636E;.</li>
  <li>Hoxy&#x62E6;&#x622A;&#x54CD;&#x5E94;&#x5E76;&#x5904;&#x7406;.</li>
  <li>&#x5BA2;&#x6237;&#x7AEF;&#x6536;&#x5230;&#x8BF7;&#x6C42;.</li>
</ol>


<h1 id="getting-started" data-tldr="Installation, etc.">Getting Started<a href="#getting-started" class="permalink" title="permalink"></a></h1>

<p>
  Hoxy&#x9700;&#x8981;Node 0.12.x&#x4EE5;&#x4E0A;&#x7248;&#x672C;&#xFF0C;io.js 1.0&#x4EE5;&#x4E0A;&#x7248;&#x672C;&#x3002;
  &#x4E0B;&#x9762;&#x662F;&#x4E00;&#x4E2A;&#x7BE1;&#x6539;&#x8BF7;&#x6C42;&#x7684;&#x5C0F;&#x4F8B;&#x5B50;
</p>

<pre class="language-javascript code">
  let hoxy = require(&apos;hoxy&apos;);
  let proxy = hoxy.createServer().listen(8080);
  proxy.intercept(&apos;request&apos;, req =&gt; {
    req.headers[&apos;x-unicorns&apos;] = &apos;unicorns&apos;;
    // server will now see the &quot;x-unicorns&quot; header
  });
</pre>

<p>
  &#x6267;&#x884C;&#x4EE3;&#x7801;&#xFF0C;&#x914D;&#x7F6E;&#x4EE3;&#x7406;&#x5730;&#x5740;&#x4E3A;<code>&#x4F60;&#x7684;ip:8080</code>&#xFF0C;&#x670D;&#x52A1;&#x5668;&#x7AEF;&#x6536;&#x5230;&#x7684;&#x8BF7;&#x6C42;header&#x4E2D;&#x5C31;&#x5305;&#x542B;&#x4E86;x-unicorns&#x3002;
  &#x53EA;&#x8981;&#x61C2;&#x5F97;Javascript&#x548C;Http&#xFF0C;&#x4F60;&#x5C31;&#x53EF;&#x4EE5;&#x968F;&#x610F;&#x7684;&#x67E5;&#x770B;&#x548C;&#x4FEE;&#x6539;&#x7F51;&#x7EDC;&#x6570;&#x636E;&#x3002;
</p>

<h2 id="installation" data-tldr="Available on npm.">Download &amp; Installation<a href="#installation" class="permalink" title="permalink"></a></h2>
<h2 id="installation" data-tldr="Available on npm.">&#x4E0B;&#x8F7D; &amp; &#x5B89;&#x88C5;<a href="#installation" class="permalink" title="permalink"></a></h2>

<p>
  &#x53EF;&#x4EE5;&#x4ECE; <a href="https://www.npmjs.org/package/hoxy">npm</a> &#x4F55; <a href="https://github.com/greim/hoxy">github</a> &#x4E0B;&#x8F7D;Hoxy.
  &#x5DF2;&#x7ECF;&#x5728;&#x6700;&#x8FD1;&#x7684;node&#x548C;io&#x7248;&#x672C;&#x4E2D;&#x6D4B;&#x8BD5;&#x901A;&#x8FC7;.
</p>

<pre class="code">
  $ npm install hoxy
</pre>

<pre class="language-javascript code">
  var hoxy = require(&apos;hoxy&apos;);
</pre>



<h1 id="api-documentaiton" data-tldr="Objects, methods, and properties.">API&#x6587;&#x6863;<a href="#api-documentaiton" class="permalink" title="permalink"></a></h1>

<h2 id="main-module" data-tldr="Entry point for all hoxy functionality.">&#x4E3B;&#x8981;&#x6A21;&#x5757;<a href="#main-module" class="permalink" title="permalink"></a></h2>

<pre class="language-javascript code">
  var hoxy = require(&apos;hoxy&apos;);
</pre>

<p>
  The object returned from <code>require(&apos;hoxy&apos;)</code> is just a namespace.
</p>

<h2 id="class-proxy">Class Proxy<a href="#class-proxy" class="permalink" title="permalink"></a></h2>

<p>
  <code>hoxy.createServer()</code>&#x5C06;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x4EE3;&#x7406;&#x670D;&#x52A1;&#x5668;
</p>

<div class="api-detail">
  <h3 id="new-proxy"><a href="#new-proxy">hoxy.createServer(<span class="args">options</span>)</a><a href="#new-proxy" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      &#x901A;&#x8FC7;&#x53C2;&#x6570;&#x751F;&#x6210;&#x4EE3;&#x7406;&#xFF0C;&#x6240;&#x6709;&#x53C2;&#x6570;&#x90FD;&#x662F;&#x53EF;&#x9009;&#x7684;.
    </p>
    <pre class="language-javascript code">
      var hoxy = require(&apos;hoxy&apos;);
      var proxy = hoxy.createServer({
        upstreamProxy: &apos;localhost:9090&apos;,
        reverse: &apos;http://example.com&apos;,
        certAuthority: { key, cert },
        tls: { key, cert },
        slow: { rate, latency, up, down }
      });
    </pre>
    <table>
      <caption>&#x53C2;&#x6570;&#x8BE6;&#x89E3;</caption>
      <thead>
        <tr>
          <th>&#x53C2;&#x6570;</th>
          <th>&#x8BE6;&#x89E3;</th>
        </tr>
      </thead>
      <tobdy>
        <tr>
          <td><code>upstreamProxy</code></td>
          <td>
            [&#x53EF;&#x9009;]&#x3002;&#x5C06;&#x5F53;&#x524D;&#x4EE3;&#x7406;&#x5C06;&#x8F6C;&#x53D1;&#x5230;&#x5176;&#x4ED6;&#x4EE3;&#x7406;&#x5730;&#x5740;&#x3002;&#x4F7F;&#x7528;&#x683C;&#x5F0F;&#xFF1A;<code>host:port</code>
          </td>
        </tr>
        <tr>
          <td><code>reverse</code></td>
          <td>
            [&#x53EF;&#x9009;].
            &#x672C;&#x4EE3;&#x7406;&#x5C06;&#x4F5C;&#x4E3A;&#x6307;&#x5B9A;&#x670D;&#x52A1;&#x5668;&#x7684;&#x53CD;&#x5411;&#x4EE3;&#x7406;&#x3002;
            If present, this proxy will run as a reverse proxy for the given server.
            This allows you to point your client directly at the proxy, instead of configuring it in the client&apos;s proxy settings.
            This value should take the form <code>scheme://host:port</code>.
          </td>
        </tr>
        <tr>
          <td><code>certAuthority&#xA0;{&#xA0;key,&#xA0;cert&#xA0;}</code></td>
          <td>
            [&#x53EF;&#x9009;].
            &#x901A;&#x8FC7;&#x8BBE;&#x7F6E;(&#x5BC6;&#x5319;/&#x8BC1;&#x4E66;)&#x5728;&#x4F60;&#x7684;&#x5BA2;&#x6237;&#x7AEF;&#x751F;&#x6210;&#x4E00;&#x4E2A;ssl&#x8BC1;&#x4E66;.&#x5728;&#x8FD9;&#x91CC;<a href="https://github.com/coolaj86/node-ssl-root-cas/wiki/Painless-Self-Signed-Certificates-in-node.js">&#x67E5;&#x770B;&#x5982;&#x4F55;&#x751F;&#x6210;&#x5BC6;&#x5319;&#x548C;&#x8BC1;&#x4E66;</a> .
            &#x4F60;&#x9700;&#x8981;&#x8BBE;&#x7F6E;&#x5BA2;&#x6237;&#x7AEF;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;https&#x4EE3;&#x7406;&#x3002;&#x8BBE;&#x7F6E;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x53EA;&#x8981;&#x4F60;&#x8BBF;&#x95EE;&#x7F51;&#x7AD9;&#xFF0C;&#x901A;&#x8FC7;&#x5728;&#x5185;&#x5B58;&#x4E2D;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x5047;&#x5BC6;&#x5319;&#x548C;&#x8BC1;&#x4E66;&#xFF0C;hoxy&#x5C06;&#x80FD;&#x591F;&#x50CF;&#x76D1;&#x542C;http&#x4E00;&#x6837;&#x76D1;&#x542C;https&#x8BF7;&#x6C42;&#x3002;
            You&apos;ll then need to configure your client to use this proxy for https in addition to http.
            Once you&apos;ve got all of that set up, Hoxy will generate fake keys/cert combos for every hostname you visit, caching them in memory for subsequent visits, thus allowing the proxy to handle https requests as cleartext.
          </td>
        </tr>
        <tr>
          <td><code>tls&#xA0;{&#xA0;key,&#xA0;cert&#xA0;}</code></td>
          <td>
            Optional.
            &#x53EA;&#x80FD;&#x7EC4;&#x5408;&#x540E;&#x7528;&#x4E8E;&#x53CD;&#x5411;&#x4EE3;&#x7406;&#xFF0C;&#x4F7F;&#x7528;&#x540E;Hoxy&#x5C06;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;https&#x670D;&#x52A1;&#x5668;&#x3002;
            Passed as <code>opts</code> to <code>https.createServer(opts, function)</code> (&#x53C2;&#x89C1; <a href="https://iojs.org/api/https.html">https&#x6587;&#x6863;</a>).
          </td>
        </tr>
        <tr>
          <td><code>slow&#xA0;{&#xA0;rate,&#xA0;latency,&#xA0;up,&#xA0;down&#xA0;}</code></td>
          <td>
            Optional.
            <ul>
              <li><code>latency</code> &#x5728;&#x6240;&#x6709;&#x8BF7;&#x6C42;&#x548C;&#x54CD;&#x5E94;&#x4E4B;&#x95F4;&#x589E;&#x52A0;&#x4E00;&#x4E2A;&#x5EF6;&#x8FDF;&#x3002;&#x5355;&#x4F4D;&#xFF08;ms&#xFF09;.</li>
              <li><code>rate</code> &#x9650;&#x5236;&#x7F51;&#x901F;&#xFF0C;&#x5355;&#x4F4D;(bytes per second).</li>
              <li><code>up</code> &#x9650;&#x5236;&#x4E0A;&#x4F20;&#x901F;&#x5EA6;(bytes per second).</li>
              <li><code>down</code> &#x9650;&#x5236;&#x4E0B;&#x8F7D;&#x901F;&#x5EA6;(bytes per second).</li>
            </ul>
            &#x6CE8;&#x610F;: <code>&#x4E0A;&#x4F20;</code> &#x548C; <code>&#x4E0B;&#x8F7D;</code> &#x662F;&#x72EC;&#x7ACB;&#x7684;.
            &#x7136;&#x800C;&#xFF0C;&#x5047;&#x5982;&#x540C;&#x65F6;&#x4F7F;&#x7528;<code>rate</code>&#x548C;<code>up</code>&#xFF0C;&#x4ED6;&#x4EEC;&#x5F53;&#x4E2D;&#x8F83;&#x6162;&#x7684;&#x5C06;&#x751F;&#x6548;&#x3002;<code>rate</code> &#x548C; <code>down</code> &#x4E5F;&#x662F;&#x4E00;&#x6837;&#x3002;
            &#x8FD9;&#x4E9B;&#x5C5E;&#x6027;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;<code>proxy.slow()</code>&#x83B7;&#x53D6;&#x6216;&#x8005;&#x8BBE;&#x7F6E;&#x3002;
          </td>
        </tr>
      </tobdy>
    </table>
  </div>
</div>

<div class="api-detail">
  <h3 id="proxy-listen"><a href="#proxy-listen">proxy.listen(<span class="args">port, [hostname], [backlog], [callback]</span>)</a><a href="#proxy-listen" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      &#x76D1;&#x542C;<code>port</code>&#x7AEF;&#x53E3;&#x5E76;&#x8FD4;&#x56DE;&#x81EA;&#x8EAB;&#xFF08;proxy&#x5B9E;&#x4F8B;&#xFF09;
    </p>
    <pre class="language-javascript code">
      var hoxy = require(&apos;hoxy&apos;);
      var proxy = hoxy.createServer().listen(8080);
    </pre>
    <p>
      &#x53EF;&#x4EE5;&#x6DFB;&#x52A0;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#xFF0C;&#x5F53;&#x4EE3;&#x7406;&#x542F;&#x52A8;&#x65F6;&#x8C03;&#x7528;&#x3002;
    </p>
    <pre class="language-javascript code">
      var hoxy = require(&apos;hoxy&apos;);
      var port = 8080;
      var proxy = hoxy.createServer().listen(port, function() {
        console.log(&apos;The proxy is listening on port &apos; + port + &apos;.&apos;);
      });
    </pre>
    <p>
      &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x53EA;&#x662F;&#x5C06;&#x6240;&#x6709;&#x53C2;&#x6570;&#x90FD;&#x4F20;&#x9012;&#x7ED9;Node&#x7684;<a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback"><code>server.listen()</code> &#x65B9;&#x6CD5;</a>&#x3002;
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="proxy-slow"><a href="#proxy-slow">proxy.slow(<span class="args">[options]</span>)</a><a href="#proxy-slow" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      &#x83B7;&#x53D6;&#x6216;&#x8005;&#x8BBE;&#x7F6E;&#x4EE3;&#x7406;&#x7F51;&#x7EDC;&#x901F;&#x5EA6;&#x7684;&#x9009;&#x9879;&#x3002;
      &#x5982;&#x679C;&#x6709;&#x53C2;&#x6570;, &#x5C31;&#x662F;&#x8BBE;&#x7F6E;&#x901F;&#x5EA6;
    </p>
    <pre class="language-javascript code">
      proxy.slow({ rate, latency, up, down });
    </pre>
    <p>
      &#x5982;&#x679C;&#x6CA1;&#x6709;&#x53C2;&#x6570;&#xFF0C;&#x5C31;&#x4F1A;&#x8FD4;&#x56DE;&#x5F53;&#x524D;&#x901F;&#x5EA6;&#x8BBE;&#x7F6E;&#x3002;
    </p>
    <pre class="language-javascript code">
      var slowOpts = proxy.slow();
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="proxy-intercept"><a href="#proxy-intercept">proxy.intercept(<span class="args">options, handler</span>)</a><a href="#proxy-intercept" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      &#x8FD9;&#x662F;&#x62E6;&#x622A;&#x548C;&#x64CD;&#x4F5C;&#x8BF7;&#x6C42;&#x6216;&#x54CD;&#x5E94;&#x6570;&#x636E;&#x7684;&#x5165;&#x53E3;&#x3002;
      &#x4E0B;&#x9762;&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x5C06;&#x62E6;&#x622A;&#x6240;&#x6709;&#x7684;&#x8BF7;&#x6C42;&#x3002;
    </p>
    <pre class="language-javascript code">
      proxy.intercept(&apos;request&apos;, req =&gt; console.log(req.url));
    </pre>
    <p>
      &#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x66F4;&#x8BE6;&#x7EC6;&#xFF0C;&#x4F46;&#x529F;&#x80FD;&#x548C;&#x4E0A;&#x9762;&#x7684;&#x76F8;&#x540C;&#x3002;
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;
      }, function(req, resp, cycle) {
        console.log(req.url);
      });
    </pre>
    <h4>Interceptors(&#x62E6;&#x622A;)</h4>
    <p>
      &#x4F20;&#x9012;&#x7ED9; <code>intercept()</code> (&#x540C;&#x540D;<em>interceptor</em>)&#x7684;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x63A5;&#x6536;&#x4E09;&#x4E2A;&#x53C2;&#x6570;<code>(req, resp, cycle)</code>&#xFF0C;&#x4ED6;&#x4EEC;&#x662F;&#x4E0B;&#x9762;&#x4ECB;&#x7ECD;&#x7684;&#x4E00;&#x4E9B;&#x7C7B;&#x7684;&#x5B9E;&#x4F8B;&#x3002;
      <code>cycle</code> is also passed as context.
      Thus:
    </p>
    <pre class="language-javascript code">
      proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
        console.log(this === cycle) // true
      });
    </pre>
    <h4>Sync versus async interceptors &#x540C;&#x6B65;&#x62E6;&#x622A;&#x5668;vs&#x5F02;&#x6B65;&#x62E6;&#x622A;&#x5668;</h4>
    <p>
      Hoxy&#x4F1A;&#x6309;&#x987A;&#x5E8F;&#x6267;&#x884C;&#x6240;&#x6709;&#x5185;&#x5BB9;&#xFF0C;&#x5305;&#x62EC;&#x62E6;&#x622A;&#x5668;&#x3002;
      &#x5F53;&#x6267;&#x884C;&#x540C;&#x6B65;&#x4EE3;&#x7801;&#x65F6;&#x6CA1;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x4F46;&#x662F;&#x5F53;&#x6267;&#x884C;&#x5F02;&#x6B65;&#x4EE3;&#x7801;&#x65F6;&#xFF0C;&#x4F60;&#x5FC5;&#x987B;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;Promise&#x3002;Hoxy&#x4F1A;&#x7B49;&#x5F85;Promise resolve&#x5B8C;&#x6BD5;&#x540E;&#x540E;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x624D;&#x4F1A;&#x7EE7;&#x7EED;&#x3002;
      Hoxy internally runs everything sequentially in series, including interceptors.
      That happens naturally when your interceptor logic is synchronous.
      But if it&apos;s asynchronous, you must signal that by returning a promise.
      As long as you do that, Hoxy will wait until the promise resolves and things will flow serially.
    </p>
    <pre class="language-javascript code">
      proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
        // return a promise from the interceptor
        return getThingA().then(function(thingA) {
          return getThingB(thingA);
        }).then(function(thingB) {
          // do something with &quot;thingB&quot;
        });
      });
    </pre>
    <p>
      Javascript&#x7684;&#x672A;&#x6765;&#x7248;&#x672C;&#x5C06;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x529F;&#x80FD;async&#x3002;
      &#x901A;&#x8FC7;&#x4E00;&#x4E9B;&#x8F6C;&#x6362;&#x5668;&#x73B0;&#x5728;&#x5C31;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x5B83;&#x3002;&#x8FD9;&#x4E9B;&#x7279;&#x6027;&#x4E5F;&#x53EF;&#x4EE5;&#x5728;&#x62E6;&#x622A;&#x5668;&#x4E2D;&#x4F7F;&#x7528;&#x3002;&#x901A;&#x8FC7;&#x65B0;&#x7684;&#x5199;&#x6CD5;&#xFF0C;&#x903B;&#x8F91;&#x64CD;&#x4F5C;&#x548C;&#x9519;&#x8BEF;&#x5904;&#x7406;&#x4E5F;&#x66F4;&#x65B0;&#x6E05;&#x6670;&#x4E86;&#x3002;
    </p>
    <pre class="language-javascript code">
      proxy.intercept(&apos;request&apos;, async function(req, resp, cycle) {
        // this is an async function
        let thingA = await getThingA();
        let thingB = await getThingB(thingA);
        // do something with &quot;thingB&quot;
      });
    </pre>
    <p>
      &#x5728;&#x5F53;&#x524D;&#x7248;&#x672C;&#x7684;io.js&#xFF0C;
      In current versions of io.js, generators can be used as a stand-in for async functions, but with the benefit of being natively-supported, spec-valid ES6 syntax.
      You must only yield <em>promises</em> from your generator.
      See <a href="https://www.npmjs.com/package/co">co</a> for more details.
    </p>
    <pre class="language-javascript code">
      proxy.intercept(&apos;request&apos;, function*(req, resp, cycle) {
        // this is a generator
        let thingA = yield getThingA();
        let thingB = yield getThingB(thingA);
        // do something with &quot;thingB&quot;
      });
    </pre>
    <p>
      <strong>Note:</strong> Strictly speaking, Hoxy doesn&apos;t care whether your interceptor is an async function or a generator.
      It only cares what kind of thing the return value is:
    </p>
    <ul>
      <li>Promise: wait for it to resolve, then  proceed.</li>
      <li>Iterator: turn it into a promise, wait for it to resolve, then  proceed.</li>
      <li>None of the above: proceed immediately.</li>
    </ul>
    <h4>Options</h4>
    <p>
      Options affect how, or if, interceptors get called.
      Here are a few examples.
      The following will only intercept <code>GET</code> requests to <code>example.com</code>.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        method: &apos;GET&apos;,
        hostname: &apos;example.com&apos;
      }, function(req, resp, cycle) {
        console.log(&apos;request made to: &apos;+req.url);
      });
    </pre>
    <p>
      The following only intercepts <code>text/html</code> responses.
      When it does, it exposes the response body as a readable/writable <code>$</code> variable.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        mimeType: &apos;text/html&apos;,
        as: &apos;$&apos;
      }, function(req, resp, cycle) {
        resp.$(&apos;title&apos;)
        .text(&apos;all your titles are belong to us&apos;);
      });
    </pre>
    <p>
      The following only intercepts responses with a declared charset.
      When it does, it exposes the response body as the <code>string</code> variable.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        contentType: /charset/i,
        as: &apos;string&apos;
      }, function(req, resp, cycle) {
        console.log(resp.string);
      });
    </pre>
    <p>
      The following only intercepts responses from an <code>/api/users</code> JSON endpoint.
      When it does, it exposes the response body as the <code>json</code> variable.
      It uses a <a href="https://github.com/bjoerge/route-pattern">URL pattern</a> to match the endpoint URL instead of a regex.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        fullUrl: &apos;http://example.com/api/users/:id&apos;,
        mimeType: &apos;application/json&apos;,
        as: &apos;json&apos;
      }, function(req, resp, cycle) {
        console.log(resp.json.email_address);
      });
    </pre>
    <table>
      <caption>Option Descriptions</caption>
      <thead>
        <tr>
          <th>name</th>
          <th class="type">type</th>
          <th>required</th>
          <th>description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>phase</code></td>
          <td class="type">string</td>
          <td>yes</td>
          <td>
            Which phase to intercept.
            See <a href="#phase-lifecycle">phase lifecycle</a> for more info.
            Accepted values:
            <ul>
              <li><code>&apos;request&apos;</code> - Proxy has received request.</li>
              <li><code>&apos;request-sent&apos;</code> - Proxy has sent request.</li>
              <li><code>&apos;response&apos;</code> - Proxy has received response.</li>
              <li><code>&apos;response-sent&apos;</code> - Proxy has sent response.</li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><code>as</code></td>
          <td class="type">string</td>
          <td>no</td>
          <td>
            Expose the request or response body (depending on the phase) as data of a certain type.
            If there&apos;s an error parsing the body into this form, the intercept action is skipped and a warning is logged.
            Hoxy normally streams request and response bodies through.
            If <code>as</code> is present, hoxy buffers the request or response body into memory.
            Accepted values:
            <ul>
              <li><code>&apos;$&apos;</code> - A DOM object similar to jQuery.
                See <a href="https://github.com/MatthewMueller/cheerio">cheerio</a>.</li>
              <li><code>&apos;json&apos;</code> - A JS object containing JSON.</li>
              <li><code>&apos;string&apos;</code> - A plain string.</li>
              <li><code>&apos;buffer&apos;</code> - A buffer containing the entity body in its raw binary form.</li>
              <li><code>&apos;params&apos;</code> - A JS object containing name/value pairs parsed from the <code>application/x-www-form-urlencoded</code> entity body.</li>
            </ul>
            Use filtering in tandem with these.
            E.g. use <code>&apos;json&apos;</code> with <code>mimeType:&apos;application/json&apos;</code>.
          </td>
        </tr>
      </tbody>
      <thead>
        <tr>
          <th class="caption" colspan="4">Filtering options (these are logically ANDed together)</th>
        </tr>
      </thead>
      <thead>
        <tr>
          <th>name</th>
          <th class="type">type</th>
          <th>required</th>
          <th>description</th>
        </tr>
      </thead>
      <body>
        <tr>
          <td><code>protocol</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the request protocol.
          </td>
        </tr>
        <tr>
          <td><code>method</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the all-uppercase HTTP request method.
          </td>
        </tr>
        <tr>
          <td><code>hostname</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the host, not including :port.
          </td>
        </tr>
        <tr>
          <td><code>port</code></td>
          <td class="type">number, string, regex, function</td>
          <td>no</td>
          <td>
            Match the port number.
          </td>
        </tr>
        <tr>
          <td><code>url</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the request URL.
            Patterns like <code>/foo/*</code> are allowed.
            See <a href="https://github.com/bjoerge/route-pattern">route-pattern</a>.
          </td>
        </tr>
        <tr>
          <td><code>fullUrl</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the full request URL including protocol and hostname.
            Patterns like <code>/foo/*</code> are allowed.
            See <a href="https://github.com/bjoerge/route-pattern">route-pattern</a>.
          </td>
        </tr>
        <tr>
          <td><code>contentType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match the full <code>content-type</code> header of the request or response (depending on the phase).
          </td>
        </tr>
        <tr>
          <td><code>requestContentType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Same as <code>contentType</code> but only matches request.
          </td>
        </tr>
        <tr>
          <td><code>responseContentType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Same as <code>contentType</code> but only matches response.
          </td>
        </tr>
        <tr>
          <td><code>mimeType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Match just the mime type portion of the <code>content-type</code> header of the request or response (depending on the phase). I.e., if the entire header is <code>&quot;text/html; charset=utf-8&quot;</code>, just match the <code>&quot;text/html&quot;</code> part.
          </td>
        </tr>
        <tr>
          <td><code>requestMimeType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Same as <code>mimeType</code> but only matches request.
          </td>
        </tr>
        <tr>
          <td><code>responseMimeType</code></td>
          <td class="type">string, regex, function</td>
          <td>no</td>
          <td>
            Same as <code>mimeType</code> but only matches response.
          </td>
        </tr>
      </body>
    </table>
    <p>
      Note: filtering options can be different types.
    </p>
    <ul>
      <li>string: a loose (<code>==</code>) match.</li>
      <li>regex: regex match of the string-coerced value.</li>
      <li>function: truthiness of return value.</li>
    </ul>
  </div>
</div>

<div class="api-detail">
  <h3 id="proxy-log"><a href="#proxy-log">proxy.log(<span class="args">levels, [handler]</span>)</a><a href="#proxy-log" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Deals with various logging events.
      This first example listens for <code>error</code>, <code>warn</code>, and <code>debug</code> logging events, and prints them to <code>stderr</code>.
    </p>
    <pre class="language-javascript code">
      proxy.log(&apos;error warn debug&apos;);
    </pre>
    <p>
      Or, print logging events to various writable streams.
    </p>
    <pre class="language-javascript code">
      proxy.log(&apos;error warn debug&apos;, process.stderr);
      proxy.log(&apos;info&apos;, process.stdout);
    </pre>
    <p>
      Or, explicitly handle logging events.
    </p>
    <pre class="language-javascript code">
      proxy.log(&apos;error warn&apos;, function(event) {
        console.error(event.level + &apos;: &apos; + event.message);
        if (event.error) console.error(event.error.stack);
      });
    </pre>
    <table>
      <caption>Description of logging events</caption>
      <thead>
        <tr>
          <th>name</th>
          <th>description</th>
        </tr>
      </thead>
      <tobdy>
        <tr>
          <td><code>error</code></td>
          <td>
            When something bad happens that we wish wouldn&apos;t have happened.
          </td>
        </tr>
        <tr>
          <td><code>warn</code></td>
          <td>
            When something iffy happened that we can probably tolerate.
          </td>
        </tr>
        <tr>
          <td><code>info</code></td>
          <td>
            When something noteworthy happened that normal people care about.
          </td>
        </tr>
        <tr>
          <td><code>debug</code></td>
          <td>
            When something boring happened that developers care about.
          </td>
        </tr>
      </tobdy>
    </table>
  </div>
</div>

<div class="api-detail">
  <h3 id="proxy-close"><a href="#proxy-close">proxy.close(<span class="args">[callback]</span>)</a><a href="#proxy-close" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Stops proxy receiving requests.
      Finalizes and/or cleans up any resources the proxy uses internally.
    </p>
    <pre class="language-javascript code">
      proxy.close(function(err) { // optional callback
        if (err) {
          throw err;
        }
        console.log(&apos;The proxy is no longer accepting new connections.&apos;);
      });
    </pre>
  </div>
</div>

<h2 id="class-request">Class Request<a href="#class-request" class="permalink" title="permalink"></a></h2>

<p>
  Represents a request.
  An instance of this is passed as the first argument to every interceptor.
  Altering its values changes what the server sees.
  If you change the <code>hostname</code>, it changes <em>which</em> server sees the request.
</p>

<div class="api-detail">
  <h3 id="request-protocol"><a href="#request-protocol">request.protocol</a><a href="#request-protocol" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Protocol of the request.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-hostname"><a href="#request-hostname">request.hostname</a><a href="#request-hostname" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Destination server hostname, sans port.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-port"><a href="#request-port">request.port</a><a href="#request-port" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Destination server port.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-method"><a href="#request-method">request.method</a><a href="#request-method" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      All-caps HTTP method used.
      Lowercase values are converted to uppercase.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-headers"><a href="#request-headers">request.headers</a><a href="#request-headers" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      HTTP request header name/value JS object.
      These are all-lowercase, e.g. <code>accept-encoding</code>.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-url"><a href="#request-url">request.url</a><a href="#request-url" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Root-relative request URL, including query string, like <code>/foo/bar?baz=qux</code>
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-query"><a href="#request-query">request.query</a><a href="#request-query" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      An object representing querystring params in the URL.
      For example if the URL is <code>/foo/bar?baz=qux</code>, then this object will look like <code>{ baz: &apos;qux&apos; }</code>.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-json"><a href="#request-json">request.json</a><a href="#request-json" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Request body parsed as JSON.
      This is only present if you intercept the request <code>as:&apos;json&apos;</code>.
      Changes made to this object will be seen by the server.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        method: &apos;PUT&apos;,
        fulUrl: &apos;http://example.com/users/:id&apos;,
        as: &apos;json&apos;
      }, function(req, resp, cycle) {
        req.json.prefs.subscriptions = &apos;all&apos;;
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-params"><a href="#request-params">request.params</a><a href="#request-params" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Request body parsed as form-url-encoded params.
      This will be a key/value <a href="https://www.google.com/search?q=POJO">POJO</a>.
      This object will only present if you intercept the request <code>as:&apos;params&apos;</code>.
      Changes made to this object will be seen by the server.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        method: &apos;POST&apos;,
        mimeType: &apos;application/x-www-form-urlencoded&apos;,
        as: &apos;params&apos;
      }, function(req, resp, cycle) {
        console.log(req.params.email);
      });
    </pre>
    <p>
      Note, parameters from the URL querystring are <em>not</em> included in this object.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-string"><a href="#request-string">request.string</a><a href="#request-string" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Request body string.
      This is only present if you intercept the request <code>as:&apos;string&apos;</code>.
      Overwriting this will overwrite the request body sent to the server.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        fulUrl: &apos;http://example.com/users/:id&apos;,
        as: &apos;string&apos;
      }, function(req, resp, cycle) {
        console.log(req.string);
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-buffer"><a href="#request-buffer">request.buffer</a><a href="#request-buffer" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Request body binary <a href="http://nodejs.org/api/buffer.html">buffer</a>.
      This is only present if you intercept the request <code>as:&apos;buffer&apos;</code>.
      Changes made to this object will be seen by the server.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        method: &apos;POST&apos;,
        fullUrl: &apos;http://example.com/images&apos;,
        as: &apos;buffer&apos;
      }, function(req, resp, cycle) {
        // req.buffer contains uploaded image
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-slow"><a href="#request-slow">request.slow(<span class="args">options</span>)</a><a href="#request-slow" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Simulates slowness during request phase.
      With this method you can set a minimum latency and/or maximum transfer rate.
      Since these are minimum/maximum, if your native connection is already slower than these values, this method will have no effect.
    </p>
    <pre class="language-javascript code">
      // Simulate upload speed of 10,000 bytes per second
      proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
        req.slow({rate:10000}); // bytes per second
      });
    </pre>
    <pre class="language-javascript code">
      // Simulate a 500-1000ms delay on every request.
      proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
        req.slow({latency:randint(500, 1000)});
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="request-fullUrl"><a href="#request-fullUrl">request.fullUrl(<span class="args">[url]</span>)</a><a href="#request-fullUrl" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      If <code>url</code> is provided, sets the request&apos;s absolute protocol, hostname, port and url.
      Otherwise it returns the absolute URL of this request.
      This is mainly a convenience method.
    </p>
    <pre class="language-javascript code">
      // Log every request through the proxy.
      proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
        console.log(req.fullUrl());
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 data-tldr="Copy the request body to any writable stream." id="request-tee"><a href="#request-tee">request.tee(<span class="args">writable</span>)</a><a href="#request-tee" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Whatever request body gets sent to the server, <code>tee()</code> pipes an identical copy to your writable stream.
      Your stream is held in memory, and only gets written to if and when the request is sent to the server.
      In other words, your stream sees whatever the server sees.
      If <a href="#response-population">the server sees nothing</a>, your stream sees nothing.
      You can <code>tee()</code> as many times as you want.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        method: /post|put/i,
        mimeType: &apos;application/json&apos;
      }, function(req, resp, cycle) {
        req.tee(fs.createWriteStream(&apos;./uploaded.json&apos;));
      });
    </pre>
  </div>
</div>

<h2 id="class-response">Class Response<a href="#class-response" class="permalink" title="permalink"></a></h2>

<p>
  Represents a response.
  An instance of this is passed as the second argument to every interceptor.
  This object is unpopulated during the <code>request</code> and <code>request-sent</code> phases.
  Altering its values changes the response to the client.
</p>

<div class="api-detail">
  <h3 id="response-statusCode"><a href="#response-statusCode">response.statusCode</a><a href="#response-statusCode" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      HTTP status code being sent to the client.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-headers"><a href="#response-headers">response.headers</a><a href="#response-headers" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      HTTP response header name/value JS object.
      Header names are all-lowercase, such as <code>&apos;content-type&apos;</code>.
    </p>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-cheerio"><a href="#response-cheerio">response.$</a><a href="#response-cheerio" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Response body parsed as DOM.
      This object is only present if you intercept the response <code>as:&apos;$&apos;</code>.
      This is a <a href="https://github.com/MatthewMueller/cheerio">cheerio</a> object, which provides a jQuery-like API.
      Changes made to it will be seen by the client.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        fullUrl: &apos;http://example.com/page.html&apos;,
        as: &apos;$&apos;
      }, function(req, resp, cycle) {
        // change the title of the page
        resp.$(&apos;title&apos;).text(&apos;Fake Title!&apos;);
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-json"><a href="#response-json">response.json</a><a href="#response-json" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Response body parsed as JSON.
      This is only present if you intercept the response <code>as:&apos;json&apos;</code>.
      Changes to this object will be seen by the client.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        method: &apos;GET&apos;,
        fullUrl: &apos;http://example.com/users/123&apos;,
        as: &apos;json&apos;
      }, function(req, resp, cycle) {
        // arbitrarily manipulate the response json
        resp.json.foo = &apos;bar&apos;;
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-string"><a href="#response-string">response.string</a><a href="#response-string" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Response body string.
      This is only present if you intercept the response <code>as:&apos;string&apos;</code>.
      Overwriting this will overwrite the response body sent to the client.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        fullUrl: &apos;http://example.com/page.html&apos;,
        as: &apos;string&apos;
      }, function(req, resp, cycle) {
        // print page to log
        console.log(resp.string);
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-buffer"><a href="#response-buffer">response.buffer</a><a href="#response-buffer" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Response body binary buffer.
      This is only present if you intercept the response <code>as:&apos;buffer&apos;</code>.
      Changes made to this object will be seen by the client.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        fullUrl: &apos;http://example.com/image.jpg&apos;,
        as: &apos;buffer&apos;
      }, function(req, resp, cycle) {
        // resp.buffer contains a jpg
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="response-slow"><a href="#response-slow">response.slow(<span class="args">options</span>)</a><a href="#response-slow" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Simulates a slow response.
      With this method you can set a minimum latency and/or maximum transfer rate.
      Since these are minimum/maximum, if your native connection is already slower than these values, this method has no effect.
    </p>
    <pre class="language-javascript code">
      // Simulate download speed of 100,000 bytes per second
      proxy.intercept(&apos;response&apos;, function(req, resp, cycle) {
        resp.slow({rate:100000}); // bytes per second
      });
    </pre>
    <pre class="language-javascript code">
      // Simulate a 500-1000ms delay on every response.
      proxy.intercept(&apos;response&apos;, function(req, resp, cycle) {
        resp.slow({latency:randint(500, 1000)});
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 data-tldr="Copy the response body to any writable stream." id="response-tee"><a href="#response-tee">response.tee(<span class="args">writable</span>)</a><a href="#response-tee" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Whatever response body gets sent to the client, <code>tee()</code> pipes an identical copy to your writable stream.
      Your stream is held in memory, and only gets written to when the response is sent to the client.
      In other words, your stream sees whatever the client sees.
      You can <code>tee()</code> as many times as you want.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;response&apos;,
        mimeType: &apos;image/gif&apos;
      }, function(req, resp, cycle) {
        resp.tee(fs.createWriteStream(&apos;./image.gif&apos;));
      });
    </pre>
  </div>
</div>

<h2 id="class-cycle">Class Cycle<a href="#class-cycle" class="permalink" title="permalink"></a></h2>

<p>
  Represents a whole request/response cycle.
  A Cycle instance is <code>this</code> in all interceptor calls, and the <em>same</em> instance is shared across an entire request/response cycle.
  It&apos;s also passed as the third argument, in order to support arrow functions.
  It provides a small number of methods not associated specifically to either the request or response.
</p>

<div class="api-detail">
  <h3 id="cycle-serve"><a href="#cycle-serve">cycle.serve(<span class="args">options</span>)</a><a href="#cycle-serve" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Provisions responses from the local filesystem.
      Generally, the reason you&apos;d do this is to be able to edit those files locally and test them as if they were live on the remote server.
      This action populates the response object; see <a href="#response-population">response population</a> for more info.
      The completion of this action is asynchronous, so <code>serve()</code> returns a promise.
      Example.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        fullUrl: &apos;http://example.com/main.js&apos;
      }, function(req, resp, cycle) {
        return cycle.serve(&apos;/Users/gr123/test/main.js&apos;);
      });
    </pre>
    <p>
      Or the more verbose-but-identical...
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        fullUrl: &apos;http://example.com/main.js&apos;
      }, function(req, resp, cycle) {
        return cycle.serve({
          path: &apos;/Users/gr123/test/main.js&apos;
        });
      });
    </pre>
    <table>
      <caption>Options</caption>
      <thead>
        <tr>
          <th>name</th>
          <th class="type">type</th>
          <th>required</th>
          <th>description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>path</td>
          <td class="type">string</td>
          <td>no</td>
          <td>
            Which file to serve.
            Defaults to the request URL.
            Normally this would be used in mutual exclusion with <code>docroot</code>.
            Strictly speaking, <code>path</code> is always rooted to <code>docroot</code>, which defaults to <code>&quot;/&quot;</code>.
          </td>
        </tr>
        <tr>
          <td>docroot</td>
          <td class="type">string</td>
          <td>no</td>
          <td>
            Which local directory to serve out of.
            Defaults to filesystem root <code>&quot;/&quot;</code>.
          </td>
        </tr>
        <tr>
          <td>strategy</td>
          <td class="type">string</td>
          <td>no</td>
          <td>
            Mainly relevant when using the <code>docroot</code> option.
            Describes the relationship between the local docroot and the remote one.
            Strictly speaking, this controls what happens when the local docroot is missing a requested file.
            Accepted values:
            <ul>
              <li>
                <code>replace</code> -
                (default)
                Replaces the remote docroot with the local one.
                In other words, if a requested file doesn&apos;t exist locally, it populates the response with a 404, even if it would have been found remotely.
              </li>
              <li>
                <code>overlay</code> -
                Overlays the local docroot on top of the remote one.
                In other words, if a requested file doesn&apos;t exist locally, the request will transparently fall through to the remote server.
              </li>
              <li>
                <code>mirror</code> -
                Automatically mirror the remote docroot locally.
                In other words, if a requested file doesn&apos;t exist locally, it&apos;s copied to the local docroot from the remote one, and will be found locally on subsequent requests.
              </li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
    <p>
      The returned promise resolves after the response has been populated.
      There are at least three use cases worth mentioning.
    </p>
    <p>
      Use case #1: Serve a specific file.
      First:
    </p>
    <pre class="code">
      $ curl http://example.com/js/main.js &gt; main.js
    </pre>
    <p>
      ...then:
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        fullUrl: &apos;http://example.com/js/main.js&apos;
      }, function(req, resp, cycle) {
        return cycle.serve(__dirname + &apos;/main.js&apos;);
      });
    </pre>
    <p>
      Use case #2: Serve out of a local docroot.
      First:
    </p>
    <pre class="code">
      $ mkdir js
      $ curl http://example.com/js/main.js &gt; js/main.js
      $ curl http://example.com/js/some-lib.js &gt; js/some-lib.js
      $ curl http://example.com/js/other-lib.js &gt; js/other-lib.js
      ...
    </pre>
    <p>
      ...then:
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        hostname: &apos;example.com&apos;,
        url: /^\/js\/.*/
      }, function(req, resp, cycle) {
        return cycle.serve({
          docroot: __dirname,
          strategy: &apos;overlay&apos;
        });
      });
    </pre>
    <p>
      Use case #3: Serve out of a local docroot.
      Similar to above, but automatically downloads the files for you, instead of having to curl them as in the above example.
      You control which files get downloaded locally by the filtering options you provide.
    </p>
    <pre class="language-javascript code">
      proxy.intercept({
        phase: &apos;request&apos;,
        hostname: &apos;example.com&apos;,
        url: /^\/js\/.*/
      }, function(req, resp, cycle) {
        return cycle.serve({
          docroot: __dirname,
          strategy: &apos;mirror&apos;
        });
      });
    </pre>
  </div>
</div>

<div class="api-detail">
  <h3 id="cycle-data"><a href="#cycle-data">cycle.data(<span class="args">name, [value]</span>)</a><a href="#cycle-data" class="permalink" title="permalink"></a></h3>
  <div class="api-detail-content">
    <p>
      Stores and retrieves data on a cycle instance.
      This is useful since the same instance is shared across all interceptors for a given request/response cycle, allowing you to share related data across disparate scopes.
      With two params this method behaves as a setter, with one param as a getter.
    </p>
    <pre class="language-javascript code">
      [&apos;request&apos;,&apos;request-sent&apos;,&apos;response&apos;,&apos;response-sent&apos;]
      .forEach(function(phase) {
        proxy.intercept(phase, function(req, resp, cycle) {
          cycle.data(phase, Date.now());
        });
      });
      proxy.intercept(&apos;response-sent&apos;, function(req, resp, cycle) {
        var reqReceived = cycle.data(&apos;request&apos;);
        var reqSent = cycle.data(&apos;request-sent&apos;);
        var respReceived = cycle.data(&apos;response&apos;);
        var respSent = cycle.data(&apos;response-sent&apos;);
        // now print some profiling data
      });
    </pre>
  </div>
</div>

<pre class="language-javascript code">
  hoxy.createServer({
    reverse: &apos;https://www.google.com&apos;,
    tls: {
      key: fs.readFileSync(&apos;path/to/my-server.key.pem),
      cert: fs.readFileSync(&apos;path/to/my-server.crt.pem&apos;)
    }
  }).listen(8080)
</pre>

<p>
  The <code>tls</code> option is passed to the underlying Node HTTPS server.
</p>



<h1 id="examples" data-tldr="Snippets of example code.">&#x5492;&#x8BED;Incantations<a href="#examples" class="permalink" title="permalink"></a></h1>
<p>
  Hoxy&#x4E0D;&#x662F;&#x5929;&#x4E0A;&#x4F17;&#x795E;&#x7684;&#x4E13;&#x7528;&#x9B54;&#x672F;&#x3002;
  &#x5B83;&#x6709;&#x76F8;&#x5F53;&#x7B80;&#x5355;&#x7684;&#x67B6;&#x6784;&#x5E76;&#x4EE5;&#x53EF;&#x4EE5;&#x9884;&#x6D4B;&#x7684;&#x65B9;&#x5F0F;&#x6267;&#x884C;&#x3002;
  &#x4F17;&#x795E;&#x5DF2;&#x7ECF;&#x9F13;&#x52B1;&#x5148;&#x77E5;&#x4EEC;&#x5199;&#x4E0B;&#x4E86;&#x4E00;&#x4E0B;&#x5492;&#x8BED;&#xFF0C;&#x8F85;&#x52A9;&#x8BAD;&#x7EC3;&#x540E;&#x6765;&#x7684;&#x8FFD;&#x968F;&#x8005;&#x3002;
</p>

<p>
  Hoxy is not Magic Cargo From The Sky Gods&#x2122;.
  It has a fairly simple core architecture, and works in a predictable way.
  In order to assist the training of acolytes, however, the Magic Sky Gods have inspired the prophets to write down these incantations in The Book Of Spells.
</p>

<h3 id="unicorns">Unicorns!<a href="#unicorns" class="permalink" title="permalink"></a></h3>

<p>
  &#x8FD9;&#x4E2A;&#x5492;&#x8BED;&#x8BA9;&#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x8F6C;&#x6362;&#x6210;dom&#x7ED3;&#x6784;&#xFF0C;&#x7136;&#x540E;&#x4FEE;&#x6539;&#x6807;&#x9898;&#xFF0C;&#x6240;&#x6709;&#x901A;&#x8FC7;&#x6B64;&#x4EE3;&#x7406;&#x8BBF;&#x95EE;&#x7684;html&#x6807;&#x9898;&#x90FD;&#x5C06;&#x662F;&#x201D;Unicorns&#xFF01;&quot;.
  This incantation makes all titles say &quot;Unicorns!&quot; by manipulating the response as DOM.
</p>

<pre class="language-javascript code">
  proxy.intercept({
    phase: &apos;response&apos;,
    mimeType: &apos;text/html&apos;,
    as: &apos;$&apos;
  }, function(req, resp) {
    resp.$(&apos;title&apos;).text(&apos;Unicorns!&apos;);
  });
</pre>

<h3 id="slow-connection">&#x7F13;&#x6162;&#x7684;&#x8FDE;&#x63A5;Slow Connection<a href="#slow-connection" class="permalink" title="permalink"></a></h3>

<p>
  &#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x6A21;&#x62DF;&#x4E00;&#x4E2A;&#x7F13;&#x6162;&#x7684;&#x8FDE;&#x63A5;&#x3002;
  &#x56E0;&#x4E3A;&#x4E24;&#x4E2A;&#x8BF7;&#x6C42;&#x4F7F;&#x7528;&#x540C;&#x4E00;&#x4E2A;&#x8FDE;&#x63A5;
  This spell simulates a slow connection.
  This is done at the proxy level since two simultaneous requests would share the same connection.
  Thus for example a limit of 100000 bps for two requests would result in a speed of 50000 bps for each.
</p>

<pre class="language-javascript code">
  hoxy.createServer({
    slow: { rate: 100000 }
  }).listen(8080);
</pre>

<h3 id="slow-website">Slow Website<a href="#slow-website" class="permalink" title="permalink"></a></h3>
<p></p>
<p>
  This spell simulates a slow website.
  It&apos;s as if just one website were slow, even if the rest of them run at normal speed.
</p>

<pre class="language-javascript code">
  proxy.intercept({
    phase: &apos;response&apos;,
    hostname: &apos;www.google.com&apos;
  }, function(req, resp) {
    resp.slow({ rate: 10000 });
  });
</pre>

<h3 id="generator-intercept">Generator Interceptors<a href="#generator-intercept" class="permalink" title="permalink"></a></h3>

<p>
  One can invoke the deep magic of generator functions.
  Which are actually just functions that can pause while they&apos;re running.
  This is useful because async stuff can happen while things are paused.
  But you need to yield promises, which means using an adapter to turn callbacks into promises.
</p>

<pre class="language-javascript code">
  var adapt = require(&apos;ugly-adapter&apos;);
  var fs = require(&apos;fs&apos;);
  proxy.intercept({
    phase: &apos;response&apos;,
    hostname: &apos;mysite.com&apos;,
    mimeType: &apos;text/html&apos;,
    as: &apos;$&apos;
  }, function*(req, resp) {
    var headerHtml = yield adapt(fs.readFile, &apos;path/to/header.html&apos;);
    resp.$(&apos;#header&apos;).html(headerHtml);
  });
</pre>

<h3 id="async-intercept">Async Interceptors<a href="#async-intercept" class="permalink" title="permalink"></a></h3>

<p>
  If one speaks the language of Babel, one can invoke the even deeper magic of async functions.
</p>

<pre class="language-javascript code">
  var adapt = require(&apos;ugly-adapter&apos;);
  var fs = require(&apos;fs&apos;);
  proxy.intercept({
    phase: &apos;response&apos;,
    hostname: &apos;mysite.com&apos;,
    mimeType: &apos;text/html&apos;,
    as: &apos;$&apos;
  }, async function(req, resp) {
    var headerHtml = await adapt(fs.readFile, &apos;path/to/header.html&apos;);
    resp.$(&apos;#header&apos;).html(headerHtml);
  });
</pre>

<h3 id="intercept-https">Intercept HTTPS<a href="#intercept-https" class="permalink" title="permalink"></a></h3>

<p>
  There&apos;s an incantation for intercepting HTTPS traffic, too.
  But you have to burn some extra incense.
  First, create your very own self-signed Certificate Authority.
  (You should only ever need to do this once.)
</p>

<pre class="code">
  # Create the key
  openssl genrsa -out ~/.ssh/my-private-root-ca.key.pem 2048
  # Create the cert
  openssl req -x509 -new -nodes -key ~/.ssh/my-private-root-ca.key.pem -days 1024 -out ~/.ssh/my-private-root-ca.crt.pem -subj &quot;/C=US/ST=Utah/L=Provo/O=ACME Signing Authority Inc/CN=example.com&quot;
</pre>

<p>
  Next, add the above root cert to your list of trusted cert authorities.
  How to do this varies.
  For example, Firefox maintains its own trusted list, while Chrome uses the OS&apos;s list.
  For specific details, consult the Ninth Scroll of P&apos;Ki (or search the web).
  Once that&apos;s done, launch Hoxy, passing in your trusted cert and its private key.
</p>

<pre class="language-javascript code">
  hoxy.createServer({
    certAuthority: {
      key: fs.readFileSync(&apos;/Users/you/.ssh/my-private-root-ca.key.pem&apos;),
      cert: fs.readFileSync(&apos;/Users/you/.ssh/my-private-root-ca.crt.pem&apos;)
    }
  }).listen(8080);
</pre>

<p>
  Finally, configure your client to proxy both HTTP and HTTPS through <code>localhost:8080</code>.
  Hoxy will use the fake cert authority to spoof certificates from any HTTPS sites it encounters, decrypting and intercepting them as cleartext using the existing intercept API.
</p>

<p>
See also: <a href="#https-proxying">basic explanation of HTTPS proxying</a>.
</p>

<h3 id="http-reverse">Create a reverse proxy<a href="#http-reverse" class="permalink" title="permalink"></a></h3>

<p>
  Suppose you want to intercept your own web traffic to reddit.com.
  One option is to create a proxy, configure your client to use it, then visit reddit.com.
  If client configuration isn&apos;t feasible, another option is to use a reverse proxy.
  In this case you&apos;d visit a url like <code>http://localhost:8080/</code> which would basically mirror the content of reddit.com.
  This is fairly easy to set up:
</p>

<pre class="language-javascript code">
  hoxy.createServer({
    reverse: &apos;http://www.reddit.com&apos;
  }).listen(8080);
</pre>

<p>
  Now you can visit <code>http://localhost:8080/</code> and reddit will be there.
  Strictly speaking, by visiting the proxy directly in your browser rather than configuring it as a proxy, you&apos;re depriving the proxy of the scheme (&quot;http:&quot;) and host (&quot;www.reddit.com&quot;) information in the URL.
  The <code>reverse</code> option provides those missing pieces of information, allowing you to visit the proxy directly.
</p>

<h3 id="https-reverse">Create an HTTPS reverse proxy<a href="#https-reverse" class="permalink" title="permalink"></a></h3>

<p>
  Suppose you wanted to reverse proxy to an HTTPS site.
  In that case you&apos;ll likely want the URL in your browser to be HTTPS as well.
  For that, just provide a key and cert that your client trusts.
  The <a href="#intercept-https">instructions above</a> already show how to create your own self-signed root CA.
  Do that, then use it to create your server&apos;s key and cert:
</p>

<pre class="code">
  # Create the key
  openssl genrsa -out ./my-server.key.pem 2048
  # Create the certificate signing request
  openssl req -new -key ./my-server.key.pem -out ./my-server.csr.pem -subj &quot;/C=US/ST=Utah/L=Provo/O=ACME Tech Inc/CN=localhost&quot;
  # Create the cert
  openssl x509 -req -in ./my-server.csr.pem -CA ~/.ssh/my-private-root-ca.crt.pem -CAkey ~/.ssh/my-private-root-ca.key.pem -CAcreateserial -out ./my-server.crt.pem -days 500
</pre>

<p>
  Then, launch your server with a <code>tls</code> option, like so:
</p>

<pre class="language-javascript code">
  hoxy.createServer({
    reverse: &apos;https://www.google.com&apos;,
    tls: {
      key: fs.readFileSync(&apos;path/to/my-server.key.pem),
      cert: fs.readFileSync(&apos;path/to/my-server.crt.pem&apos;)
    }
  }).listen(8080);
</pre>

<p>
  The <code>tls</code> option is passed to the underlying Node HTTPS server.
</p>

<p>
  See also: <a href="#https-proxying">basic explanation of HTTPS proxying</a>.
</p>



<h1 id="appendix" data-tldr="Extensive info on various topics.">Appendix<a href="#appendix" class="permalink" title="permalink"></a></h1>

<h2 id="phase-lifecycle" data-tldr="How phases work.">Phase lifecycle<a href="#phase-lifecycle" class="permalink" title="permalink"></a></h2>

<table>
  <caption>Full description of phases</caption>
  <thead>
    <tr>
      <th>#</th>
      <th>phase</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>
        <code>request</code>
      </td>
      <td>
        The proxy has received the request headers, but the request body (if there is one) hasn&apos;t started streaming in yet.
        Or, if you&apos;ve intercepted a request <code>as:&apos;json&apos;</code> (for example) then the request body will have been fully buffered into memory and be available as <code>request.json</code> (for example).
        See <a href="#proxy-intercept">intercepts</a> for more info.
      </td>
    </tr>
    <tr>
      <td>2</td>
      <td>
        <code>request-sent</code>
      </td>
      <td>
        The proxy has finished sending the entire request, including the request body if present, to the server.
        Everything is read-only during this phase.
        The main reason for its existence is to be able to measure the time it takes to upload the <code>request</code> by comparing it with the previous phase.
      </td>
    </tr>
    <tr>
      <td>3</td>
      <td>
        <code>response</code>
      </td>
      <td>
        The proxy has received the response headers, but the response body hasn&apos;t started streaming in yet.
        Or, if you&apos;ve intercepted a response <code>as:&apos;$&apos;</code> (for example) then the response body will have been fully buffered into memory and be available as <code>response.$</code> (for example).
        See <a href="#proxy-intercept">intercepts</a> for more info.
      </td>
    </tr>
    <tr>
      <td>4</td>
      <td style="white-space:nowrap">
        <code>response-sent</code>
      </td>
      <td>
        The proxy has finished sending the entire response, including the response body, to the client.
        Everything is read-only during this phase.
        The main reason for its existence is to be able to measure the time it takes to download the <code>response</code> by comparing it with the previous phase.
      </td>
    </tr>
  </tbody>
</table>

<p>
  Intercept handlers are called in the order of their <code>phase</code>.
  Intercept handlers of the same <code>phase</code> are called in the order they&apos;re declared.
  <code>request</code> and <code>response</code> objects are either read-only or readable/writable, depending on <code>phase</code>.
  Attempts to write a read-only thing will fail silently, generating an <a href="#proxy-log"><code>error</code> log event</a>.
</p>

<table>
  <thead>
    <tr>
      <th rowspan="2" colspan="2">Readability / writability matrix</th>
      <th colspan="2">Object</th>
    </tr>
    <tr>
      <th><code>request</code></th>
      <th><code>response</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4">Phase</th>
      <th><code>request</code></th>
      <td><span style="color:#000">writable</span></td>
      <td><span style="color:#000">writable</span></td>
    </tr>
    <tr>
      <th><code>request-sent</code></th>
      <td><span style="color:#bbb">read-only</span></td>
      <td><span style="color:#bbb">read-only</span></td>
    </tr>
    <tr>
      <th><code>response</code></th>
      <td><span style="color:#bbb">read-only</span></td>
      <td><span style="color:#000">writable</span></td>
    </tr>
    <tr>
      <th><code>response-sent</code></th>
      <td><span style="color:#bbb">read-only</span></td>
      <td><span style="color:#bbb">read-only</span></td>
    </tr>
  </tbody>
</table>

<h2 id="response-population" data-tldr="Suppressing server calls.">Response population<a href="#response-population" class="permalink" title="permalink"></a></h2>

<p>
  Hoxy normally populates responses by sending the request to the destination server during the normal request/response lifecycle.
  Alternatively, if you modify any aspect of the response before this happens (i.e. during the <code>request</code> phase) hoxy treats the <em>entire</em> response as populated, and skips the call to the destination server.
  If you modify any aspect of the response after this happens  (i.e. during the <code>response</code> phase) it overwrites just that aspect of the response from the server.
</p>

<pre class="language-javascript code">
  proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
    response.string = &apos;Hello&apos;;
    // The response is now populated so the
    // server call is skipped. Status code will
    // default to 200.
  });
</pre>

<pre class="language-javascript code">
  proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
    response.statusCode = 200;
    // The response is now populated so the
    // server call is skipped. Response body
    // defaults to empty.
  });
</pre>

<pre class="language-javascript code">
  proxy.intercept(&apos;response&apos;, function(req, resp, cycle) {
    response.string = &apos;Hello&apos;;
    // The response was already populated,
    // we just overwrite its body. Status
    // code remains the same.
  });
</pre>

<pre class="language-javascript code">
  proxy.intercept(&apos;response&apos;, function(req, resp, cycle) {
    response.statusCode = 666;
    // The response was already populated,
    // we just overwrote the status. I
    // wonder how the browser will react
    // to this unexpected turn of events.
  });
</pre>

<h2 id="change-accumulation" data-tldr="Behavior over sequential handlers.">Change accumulation<a href="#change-accumulation" class="permalink" title="permalink"></a></h2>

<p>
  Changes to requests and responses are cumulative over the whole request/response cycle.
  Among other things, this affects loading content <code>as</code> a certain type, and filtering.
</p>

<p>
  Change accumulation example.
</p>

<pre class="language-javascript code">
  proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
    req.headers[&apos;cache-control&apos;] = undefined;
  });

  proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
    console.log(req.headers[&apos;cache-control&apos;]); // undefined
  });
</pre>

<p>
  Change accumulation affects filtering.
</p>

<pre class="language-javascript code">
  proxy.intercept(&apos;request&apos;, function(req, resp, cycle) {
    req.hostname = &apos;example.com&apos;;
  });

  proxy.intercept({
    phase: &apos;request&apos;,
    hostname: &apos;other.com&apos;
  }, function(req, resp, cycle) {
    // never called!
  });
</pre>

<p>
  Change accumulation affecting <code>as</code> parameters.
</p>

<pre class="language-javascript code">
  proxy.intercept({
    phase: &apos;response&apos;,
    mimeType: &apos;application/json&apos;,
    as: &apos;json&apos;
  }, function(req, resp, cycle) { ... });

  proxy.intercept({
    phase: &apos;response&apos;,
    mimeType: &apos;application/json&apos;
  }, function(req, resp, cycle) {
    console.log(typeof resp.json); // &apos;object&apos;
  });

  proxy.intercept({
    phase: &apos;response&apos;,
    mimeType: &apos;application/json&apos;,
    as: &apos;string&apos;
  }, function(req, resp, cycle) { ... });

  proxy.intercept({
    phase: &apos;response&apos;,
    mimeType: &apos;application/json&apos;
  }, function(req, resp, cycle) {
    console.log(typeof resp.json); // &apos;undefined&apos;
    console.log(typeof resp.string); // &apos;string&apos;
  });
</pre>

<h2 id="https-proxying" data-tldr="How HTTPS proxying works">HTTPS Proxying<a href="#https-proxying" class="permalink" title="permalink"></a></h2>

<p>
How does HTTPS proxying work in Hoxy?
First, let&apos;s review how HTTPS proxying works in general.
Suppose you want to insert a proxy between yourself and the website <em>https://example.com</em>.
There are two ways to do this: direct and reverse proxying.
</p>

<h3 id="direct-https-proxying">Direct HTTPS proxying<a href="#direct-https-proxying" class="permalink" title="permalink"></a></h3>

<p>
To set up a direct HTTPS proxy, you&apos;d launch a proxy on port 8080 and set your browser to do HTTPS proxying through <code>localhost:8080</code>, then visit the site directly from your browser.
What happens here differs radically from HTTP proxying.
During HTTP proxying, the client sends this:
</p>

<pre class="code">
  GET http://www.example.com/foo.html HTTP/1.1
</pre>

<p>
In English this means <em>go to example.com and get /foo.html for me.</em>
But during HTTPS proxying, the client sends this:
</p>

<pre class="code">
  CONNECT example.com:443 HTTP/1.1
</pre>

<p>
Which in English means <em>connect me to example.com, I want to have a private conversation with them.</em>
Once the proxy establishes the pipe, the client TLS-handshakes the server on that connection.
Then, it sends normal HTTP traffic over it like this:
</p>

<pre class="code">
  GET /foo.html HTTP/1.1
</pre>

<p>
...but it&apos;s encrypted, so the proxy can&apos;t see it.
Anything might be happening on that connection, from the proxy&apos;s POV.
</p>

<p>
This is formally known as <a href="https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling">HTTP CONNECT tunneling</a>.
Since the proxy isn&apos;t privy to the conversation, there&apos;s no need for it to be an HTTPS server itself, even though &quot;https://&quot; appears in the browser&apos;s URL bar.
Its job is just to shovel TCP packets back and forth, which happen to contain undecypherable TLS traffic.
</p>

<h3 id="reverse-https-proxying">Reverse HTTPS proxying<a href="#reverse-https-proxying" class="permalink" title="permalink"></a></h3>

<p>
A reverse HTTPS proxy is a different animal altogether.
To set it up, you&apos;d launch a proxy on port 8080.
Since this is a reverse HTTPS proxy, you&apos;ll need a few more startup options:
</p>

<ol>
  <li>A private key.</li>
  <li>A certificate signed by the above key, with <code>CN=localhost</code>.</li>
  <li>The reverse proxy target, consisting of <code>&quot;https://example.com&quot;</code>.</li>
</ol>

<p>
The key and the cert in particular are necessary because a reverse proxy&#x2014;from the client&apos;s POV&#x2014;isn&apos;t a proxy at all, but an HTTPS webserver that speaks TLS.
And because of the constraints of <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">PKI</a>, the client needs to trust the cert provided above.
So one of two things needs to happen:
</p>

<ol>
  <li>The cert needs to be signed by a known CA, which requires giving somebody money.</li>
  <li>You must self-sign your own CA, make your client trust it, and sign the above cert with it.</li>
</ol>

<p>
Either way you&apos;ll end up with a signed, trusted cert and your reverse proxy should work.
</p>

<h3 id="hoxy-https-proxying">So how does Hoxy figure into this?<a href="#hoxy-https-proxying" class="permalink" title="permalink"></a></h3>

<p>
Hoxy follows these patterns, but with one major deviation having to do with direct proxying and HTTPS CONNECT tunneling.
Instead of connecting the client to the remote server, Hoxy connects the client to its own private HTTPS server.
This is a separate server instance from the proxy itself and solely exists to spoof TLS.
</p>

<p>
Normally, the client would immediately realize something fishy is going on.
The spoofing server, being TLS, has provided a cert to the client that hasn&apos;t been signed by a client-trusted CA.
Thus, to use Hoxy as an HTTPS direct proxy, you must create your <em>own</em> self-signed root CA, make your client trust it, then pass it to Hoxy as a startup option.
</p>

<p>
With this in mind, let&apos;s rewind to just before the client realizes something fishy is going on.
Hoxy, having in its possession both the cert AND the private key of a client-trusted CA, will use it to generate <em>spoofed</em> keys and certs, signed by that CA, for each HTTPS domain the client visits.
From the client&apos;s POV now, nothing fishy is going on.
As far as it knows, its CONNECT requests are being honored by the proxy, and it&apos;s talking directly to the remote website in a private channel.
</p>

<p>
But in reality, the client is tunneling to an imposter server, its traffic is being decrypted and intercepted, then being re-encrypted and sent onward.
Neither the client nor the server are the wiser.
</p>

<h3 id="tls-certauthority-diff">&quot;tls&quot; versus &quot;certAuthority&quot;<a href="#tls-certauthority-diff" class="permalink" title="permalink"></a></h3>

<p>
You may have noticed there are two key/cert options that can be passed to Hoxy, with different names: <code>tls</code> and <code>certAuthority</code>.
It should now make sense why.
The former is for reverse proxying, and is just Node&apos;s config option for running an HTTPS webserver.
The latter is for direct proxying.
It&apos;s a meta-key/cert combo, used to spoof <em>actual</em> key/cert combos on the fly.
Incidentally, these two options are mutually exclusive.
It wouldn&apos;t make sense to use both at the same time.
</p>

<p>
To see some openssl commands and HTTPS proxy specimens, see the <a href="#examples">examples section</a>.
</p>

</div>

<h2 id="other" data-tldr="Copyright, license, etc.">Other info</h2>

<ul>
  <li>Copyright &#xA9; 2015 by <a href="https://github.com/greim">Greg Reimer</a></li>
  <li>MIT License</li>
  <li><a href="https://github.com/greim/hoxy">Project on GitHub</a></li>
  <li><a href="https://www.npmjs.org/package/hoxy">Project on npm</a></li>
</ul>

<ul id="nav"></ul>
</div>

<a href="https://github.com/laomu1988/hoxy"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>

<script src="./page-resources/docs.js"></script>

</div></body>
</html>

